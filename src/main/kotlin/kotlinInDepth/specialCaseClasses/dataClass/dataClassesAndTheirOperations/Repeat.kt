package kotlinInDepth.specialCaseClasses.dataClass.dataClassesAndTheirOperations

/*
Вопросы:
1) Чем data class похож на обычный?
2) Какие функции генерируются под капотом?
3) Что такое componentN(), который генерирует в них компилятор?
4) Когда и зачем компилятор использует такие функции?
5) Почему такие классы должны иметь хотя бы 1 property в конструкторе?
6) Что делает метод copy()? Сколько их генерирует компилятор и почему?
7) Как имплементирован equals()? Что он сравнивает и как?

Ответы:
1) Это такой же класс, только со сгенерированными автоматически методами.
Все его properties также являются private, к ним сгенерированы геттеры.
2) геттеры, componentN(), copy(), toString(), hashCode() и equals().
3) Это те же геттеры, что и get[название переменной](). Номера N в componentN соответствуют
порядковому номеру property в primary конструкторе.
4) При Destructuring declaration, например. Ведь нам важно взять эти property строго в том порядке, в
котором они прописаны в primary конструкторе.
5) Потому что без property это будет обычный класс, в то время как предназначение data-класса: содержать какие-либо данные.
6) copy() нужен для создания нового объекта на базе того, copy() которого был вызван. Можно в него ничего не передать,
тогда сы создадим точную копию с другим адресом, а можно изменить некоторые параметры прямо в скобках метода copy().
Компилятор создаёт 2 метода copy(): один со всеми аргументами и второй для случаев, когда отсутствуют 1 и более аргументов.
Он проверяет, что ему дали и копирует те значения, которые не были заданы.
7) Он проверяет, является ли сравниваемый объект и исходный instance'ом одного класса. Если да, то сравнивает их
properties попарно, а если нет - проверяет их адреса.

Практика:
1) Создайте data class Car с полями model, horsePower и licensePlate.
В main() создайте её экземпляр и через scope function выведите этот
экземпляр (его данные).
 */