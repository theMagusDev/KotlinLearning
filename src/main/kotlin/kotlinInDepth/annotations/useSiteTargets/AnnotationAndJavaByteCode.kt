package kotlinInDepth.annotations.useSiteTargets

/*

class Cat(val name: String)

The 'name' property in the primary constructor has multiple
Java elements corresponding to such Kotlin elements
as get, set, field, etc. (see 'name_property.png')

That means that there may be multiple possible locations for
the annotation in the generated Java bytecode. This is a problem,
as most libraries and frameworks are made for Java. Kotlin,
however, is different from Java: for example, you don't need to write
'get' and 'set' methods in Kotlin, as they will be generated
automatically and you can customize them later, as you already know.

To get a predictable result from a library or framework,
you need to specify which element the framework will work with.
The solution is use-site targets.

We can specify how exactly an annotation should be
generated by using the following syntax (see use-site_syntax.png:

    @get:Cool
     ^     ^
 use-site  Annotation
  target

Below is an example:
 */

annotation class Cool

// annotate Java getter
class Cat(@get:Cool val name: String)

// We can apply multiple annotations to the same target by putting
// these annotations in brackets separated by a space:
annotation class Wild
annotation class Long
class Dog(@get:[Cool Wild Long] val name: String)
